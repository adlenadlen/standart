<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Пикетаж трассы — GeoJSON + частичная OSM</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #map { background: #f2f5f8; }
    .leaflet-control-attribution { display: none; }
    .leaflet-bar.ctrl { background:#fff; border-radius:4px; padding:4px; }
    .leaflet-bar.ctrl button { display:block; width:160px; margin:2px 0; border:1px solid #d0d7de; border-radius:4px; padding:6px 8px; cursor:pointer; }
    .leaflet-bar.ctrl button:hover { background:#f6f8fa; }
    .lbl { background:rgba(255,255,255,.85); padding:2px 6px; border-radius:4px; box-shadow:0 1px 2px rgba(0,0,0,.1); }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

  <script>
    // ===================== ПАРАМЕТРЫ =====================
    const GEOJSON_URL = 'https://raw.githubusercontent.com/adlenadlen/standart/main/public/docs/balkhash/map.geojson';

    const LABEL_ZOOM = 15;             // с какого зума показывать подписи (>=15)
    const MAX_LABELS = 500;            // ограничение на количество видимых подписей
    const THIN_ZOOM_THRESHOLD = 12;    // при этом зуме и ниже — прореживаем точки

    function thinningStride(z){
      if (z <= 8) return 12;   // очень редкие
      if (z <= 10) return 6;   // реже
      if (z <= 12) return 3;   // умеренно
      return 1;                // без прореживания
    }

    // ===================== КАРТА =====================
    const map = L.map('map', {
      zoomControl: false,
      attributionControl: false,
      preferCanvas: true,
      inertia: true,
      zoomSnap: 0,               // плавный зум
      zoomDelta: 0.25,
      wheelDebounceTime: 20,
      wheelPxPerZoomLevel: 120,
      maxBoundsViscosity: 1      // «жесткая» привязка к границе данных (задаём позже)
    }).setView([48, 68], 5);

    const canvasRenderer = L.canvas({ padding: 0.5 });
    // Будущий слой тайлов OSM — добавим ПОСЛЕ вычисления границ данных
    let osmTiles = null; // будет ограничен рамкой данных и не будет грузить/рисовать тайлы вне её

    // Кнопки управления: «Местоположение» и «Показать до границы»
    let userMarker = null, accuracyCircle = null, didInitialUserCenter = false;
    function centerOnUser() {
      if (userMarker) map.setView(userMarker.getLatLng(), 17);
    }

    let dataBounds = null; // границы всего GeoJSON

    const ControlButtons = L.Control.extend({
      options: { position: 'bottomright' },
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-bar ctrl');
        const btn1 = L.DomUtil.create('button', 'b', div); btn1.textContent = 'Местоположение';
        btn1.addEventListener('click', centerOnUser);
        const btn2 = L.DomUtil.create('button', 'b', div); btn2.textContent = 'Показать до границы';
        btn2.style.display = 'block'; btn2.style.marginTop = '6px';
        btn2.addEventListener('click', () => { if (dataBounds && dataBounds.isValid()) map.fitBounds(dataBounds, { padding: [24,24] }); });
        return div;
      }
    });
    map.addControl(new ControlButtons());

    // Слои: линии/полигоны отдельно, точки — отдельно (для быстрого прореживания)
    const shapesLayer = L.geoJSON(null, {
      renderer: canvasRenderer,
      style: f => ({ color: '#0066ff', weight: 2, opacity: 0.9, fillOpacity: 0.06 })
    }).addTo(map);

    const pointsLayer = L.geoJSON(null, {
      renderer: canvasRenderer,
      pointToLayer: (feature, latlng) => L.circleMarker(latlng, { renderer: canvasRenderer, radius: 4, weight: 1, color: '#0040a0', fillOpacity: 0.9 })
    }).addTo(map);

    // Подписи (лениво, только на нужном масштабе и в видимой области)
    const labelLayer = L.layerGroup([], { pane: 'tooltipPane' }).addTo(map);
    const featureStore = { points: [], shapes: [] };
    const labelIndex = new Map(); // key -> tooltipLayer

    function nameOf(f){ const p = (f && f.properties) || {}; return p.name || p.Name || p.title || p.Title || p['Название'] || ''; }
    function featureKey(f, i){ return f.id || f.properties?.id || ('f'+i); }

    function refreshLabels() {
      const show = map.getZoom() >= LABEL_ZOOM;
      if (!show) { labelLayer.clearLayers(); labelIndex.clear(); return; }
      const bounds = map.getBounds();
      let shown = 0;

      // убрать подписи, вышедшие за экран
      for (const [key, layer] of Array.from(labelIndex.entries())) {
        if (!bounds.contains(layer.getLatLng())) { labelLayer.removeLayer(layer); labelIndex.delete(key); }
      }

      function tryAddForFeature(f, idx){
        if (shown >= MAX_LABELS) return;
        const nm = nameOf(f); if (!nm) return;
        let latlng = null;
        if (f.geometry?.type === 'Point') {
          latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
        } else {
          try { latlng = L.geoJSON(f).getBounds().getCenter(); } catch(_) {}
        }
        if (!latlng || !bounds.contains(latlng)) return;
        const key = featureKey(f, idx);
        if (!labelIndex.has(key)) {
          const tt = L.tooltip({ permanent: true, direction: 'top', offset: [0, -8], className: 'lbl' })
                        .setContent(nm).setLatLng(latlng);
          tt.addTo(labelLayer); labelIndex.set(key, tt); shown++;
        }
      }

      for (let i = 0; i < featureStore.points.length && shown < MAX_LABELS; i++) tryAddForFeature(featureStore.points[i], i);
      for (let i = 0; i < featureStore.shapes.length && shown < MAX_LABELS; i++) tryAddForFeature(featureStore.shapes[i], i);
    }

    function refreshPoints(){
      const z = map.getZoom();
      const stride = z <= THIN_ZOOM_THRESHOLD ? thinningStride(z) : 1;
      const bounds = map.getBounds();
      pointsLayer.clearLayers();
      if (!featureStore.points.length) return;
      const out = [];
      let keep = 0;
      for (let i = 0; i < featureStore.points.length; i++) {
        if (stride > 1 && (i % stride) !== 0) continue; // прореживание
        const f = featureStore.points[i];
        const c = f.geometry && f.geometry.coordinates; if (!c) continue;
        const ll = L.latLng(c[1], c[0]);
        if (!bounds.contains(ll)) continue; // рисуем только в видимой области
        out.push(f); keep++;
        if (keep > 6000 && stride === 1) break; // предохранитель
      }
      if (out.length) pointsLayer.addData({ type: 'FeatureCollection', features: out });
    }

    // Обновляем подписи/точки (throttle через rAF)
    let raf = 0;
    function scheduleRefresh(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(() => { refreshPoints(); refreshLabels(); }); }
    map.on('zoomend moveend', scheduleRefresh);

    // Геолокация (первый фикс — центрирование, далее без автоцентрирования)
    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        const ll = [latitude, longitude];
        if (!userMarker) userMarker = L.marker(ll, { title: 'Вы здесь' }).addTo(map); else userMarker.setLatLng(ll);
        if (!accuracyCircle) accuracyCircle = L.circle(ll, { radius: accuracy||0, weight: 1, opacity: 0.5, fillOpacity: 0.06 }).addTo(map);
        else { accuracyCircle.setLatLng(ll); accuracyCircle.setRadius(accuracy||0); }
        // автоцентрируем только если точка внутри границ данных (чтобы не «вырвать» карту)
        if (!didInitialUserCenter) {
          if (!dataBounds || dataBounds.pad(0.2).contains(ll)) {
            map.setView(ll, 17, { animate: false }); didInitialUserCenter = true;
          }
        }
      }, err => { console.warn('Геолокация:', err.message); }, { enableHighAccuracy: true, maximumAge: 15000, timeout: 20000 });
    }

    // ===================== ЗАГРУЗКА GEOJSON =====================
    async function loadGeoJSONFromUrl(url){
      try {
        const res = await fetch(url, { cache: 'force-cache', mode: 'cors' });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const gj = await res.json();

        const feats = (gj && gj.type === 'FeatureCollection') ? gj.features : (gj && gj.type === 'Feature' ? [gj] : []);
        if (!feats.length) return;

        // разделим по типам
        featureStore.points = []; featureStore.shapes = [];
        for (const f of feats){
          const t = f.geometry && f.geometry.type;
          if (t === 'Point') featureStore.points.push(f); else featureStore.shapes.push(f);
        }

        // рисуем линии/полигоны сразу (целиком)
        if (featureStore.shapes.length){
          shapesLayer.addData({ type: 'FeatureCollection', features: featureStore.shapes });
        }

        // --- границы всего набора ---
        let b = null;
        try {
          if (feats.length) { b = L.geoJSON({ type: 'FeatureCollection', features: feats }).getBounds(); }
        } catch(_){}
        if (b && b.isValid()) dataBounds = b;

        // Добавим OSM тайлы ТОЛЬКО ПОСЛЕ того, как узнали границы — чтобы карта была «частичной»
        ensureOSMWithinDataBounds();

        // показать границы данных (если ещё не центрировались на пользователе)
        if (!didInitialUserCenter && dataBounds && dataBounds.isValid()) map.fitBounds(dataBounds, { padding: [24,24] });

        scheduleRefresh();
      } catch (e) {
        console.error('GeoJSON load error:', e);
      }
    }
    // Кастомный тайл-слой, который пропускает (не загружает и не рисует) тайлы вне заданной рамки
    const BoundedTileLayer = L.TileLayer.extend({
      initialize: function(url, options){
        L.TileLayer.prototype.initialize.call(this, url, options);
        this._clipLatLngBounds = options.clipLatLngBounds || null;
      },
      _addTile: function(coords, container){
        if (this._clipLatLngBounds) {
          const tb = this._tileCoordsToBounds(coords);
          if (!this._clipLatLngBounds.intersects(tb)) return; // пропускаем тайл полностью
        }
        return L.TileLayer.prototype._addTile.call(this, coords, container);
      }
    });

    let outsideMask = null;
    function drawOutsideMask(){
      if (!dataBounds || !dataBounds.isValid()) return;
      if (outsideMask) { map.removeLayer(outsideMask); outsideMask = null; }
      const sw = dataBounds.getSouthWest();
      const ne = dataBounds.getNorthEast();
      const nw = L.latLng(ne.lat, sw.lng);
      const se = L.latLng(sw.lat, ne.lng);
      // «Мировой» прямоугольник с дыркой по рамке данных — визуально скрывает тайлы снаружи
      const world = [[-89.999, -360.0], [-89.999, 360.0], [89.999, 360.0], [89.999, -360.0]];
      const hole = [ [sw.lat, sw.lng], [nw.lat, nw.lng], [ne.lat, ne.lng], [se.lat, se.lng] ];
      outsideMask = L.polygon([world, hole], { stroke:false, fill:true, fillOpacity:1, fillColor:'#f2f5f8', interactive:false }).addTo(map);
    }

    function ensureOSMWithinDataBounds(){
      if (osmTiles || !dataBounds || !dataBounds.isValid()) return;
      const padded = dataBounds.pad(0.15); // небольшой отступ
      map.setMaxBounds(padded);

      // Подключаем OSM, но с ЖЁСТКИМ ограничением загрузки по рамке данных
      osmTiles = new BoundedTileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        noWrap: true,
        crossOrigin: true,
        updateWhenIdle: true,
        keepBuffer: 1,
        clipLatLngBounds: dataBounds // ключ: тайлы вне этой рамки вообще не создаются
      }).addTo(map);

      // Визуально «обрубаем» область вне рамки (фон вместо карты)
      drawOutsideMask();
    }

    // Старт
    loadGeoJSONFromUrl(GEOJSON_URL);
  </script>
</body>
</html>
