<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Карта: KML + Геолокация (без подложки)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #map { background: #f2f5f8; }
    .leaflet-control-attribution { display: none; }
    .leaflet-bar.ctrl { background:#fff; border-radius:4px; padding:4px; }
    .leaflet-bar.ctrl button { display:block; width:120px; margin:2px 0; }
    .zoom-ind { background:#fff; padding:2px 6px; border-radius:4px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@5.8.0/dist/togeojson.umd.js"></script>

  <script>
    // --- Параметры производительности и поведения ---
    const LABEL_ZOOM = 15;             // с какого зума показывать подписи (>=16)
    const MAX_LABELS = 500;            // ограничение на количество видимых подписей
    const CHUNK_SIZE = 1200;           // порция фич при добавлении
    const THIN_ZOOM_THRESHOLD = 12;    // при этом зуме и ниже — прореживаем точки

    function thinningStride(z){
      if (z <= 8) return 12;   // очень редкие
      if (z <= 10) return 6;   // реже
      if (z <= 12) return 3;   // умеренно
      return 1;                // без прореживания
    }

    // --- Карта без тайлов; максимум производительности ---
    const map = L.map('map', {
      zoomControl: false,
      attributionControl: false,
      preferCanvas: true,
      inertia: true,
      zoomSnap: 0,               // плавный зум
      zoomDelta: 0.25,
      wheelDebounceTime: 20,
      wheelPxPerZoomLevel: 120
    }).setView([48, 68], 4);

    const canvasRenderer = L.canvas({ padding: 0.5 });

    // Кнопки управления: «Местоположение» и «Показать до границы»
    let userMarker = null, accuracyCircle = null, didInitialUserCenter = false;
    function centerOnUser() { if (userMarker) map.setView(userMarker.getLatLng(), 17); }

    const ControlButtons = L.Control.extend({
      options: { position: 'bottomright' },
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-bar ctrl');
        const btn1 = L.DomUtil.create('button', 'b', div); btn1.textContent = 'Местоположение';
        btn1.addEventListener('click', centerOnUser);
        const btn2 = L.DomUtil.create('button', 'b', div); btn2.textContent = 'Показать до границы';
        btn2.style.display = 'block'; btn2.style.marginTop = '6px';
        btn2.addEventListener('click', () => { if (kmlBounds && kmlBounds.isValid()) map.fitBounds(kmlBounds, { padding: [24,24] }); });
        return div;
      }
    });
    map.addControl(new ControlButtons());

    // Слои: линии/полигоны отдельно, точки — отдельно (для быстрого прореживания)
    const shapesLayer = L.geoJSON(null, {
      renderer: canvasRenderer,
      style: f => ({ color: '#0066ff', weight: 2, opacity: 0.9, fillOpacity: 0.06 })
    }).addTo(map);

    const pointsLayer = L.geoJSON(null, {
      renderer: canvasRenderer,
      pointToLayer: (feature, latlng) => L.circleMarker(latlng, { renderer: canvasRenderer, radius: 4, weight: 1, color: '#0040a0', fillOpacity: 0.9 })
    }).addTo(map);

    // --- Подписи объектов (лениво, только на нужном масштабе и в видимой области) ---
    const labelLayer = L.layerGroup([], { pane: 'tooltipPane' }).addTo(map);
    const featureStore = { points: [], shapes: [] };
    let kmlBounds = null; // границы всего KML
    const labelIndex = new Map(); // key -> tooltipLayer

    function nameOf(f){ const p = (f && f.properties) || {}; return p.name || p.Name || p.title || p.Title || ''; }
    function featureKey(f, i){ return f.id || f.properties?.id || ('f'+i); }

    function refreshLabels() {
      const show = map.getZoom() >= LABEL_ZOOM;
      if (!show) { labelLayer.clearLayers(); labelIndex.clear(); return; }
      const bounds = map.getBounds();
      let shown = 0;

      for (const [key, layer] of Array.from(labelIndex.entries())) {
        if (!bounds.contains(layer.getLatLng())) { labelLayer.removeLayer(layer); labelIndex.delete(key); }
      }

      function tryAddForFeature(f, idx){
        if (shown >= MAX_LABELS) return;
        const nm = nameOf(f); if (!nm) return;
        let latlng = null;
        if (f.geometry?.type === 'Point') {
          latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
        } else {
          try { latlng = L.geoJSON(f).getBounds().getCenter(); } catch(_) {}
        }
        if (!latlng || !bounds.contains(latlng)) return;
        const key = featureKey(f, idx);
        if (!labelIndex.has(key)) {
          const tt = L.tooltip({ permanent: true, direction: 'top', offset: [0, -8], className: 'lbl' })
                        .setContent(nm).setLatLng(latlng);
          tt.addTo(labelLayer); labelIndex.set(key, tt); shown++;
        }
      }

      for (let i = 0; i < featureStore.points.length && shown < MAX_LABELS; i++) tryAddForFeature(featureStore.points[i], i);
      for (let i = 0; i < featureStore.shapes.length && shown < MAX_LABELS; i++) tryAddForFeature(featureStore.shapes[i], i);
    }

    function refreshPoints(){
      const z = map.getZoom();
      const stride = z <= THIN_ZOOM_THRESHOLD ? thinningStride(z) : 1;
      const bounds = map.getBounds();
      pointsLayer.clearLayers();
      if (!featureStore.points.length) return;
      const out = [];
      let keep = 0;
      for (let i = 0; i < featureStore.points.length; i++) {
        if (stride > 1 && (i % stride) !== 0) continue; // прореживание
        const f = featureStore.points[i];
        const c = f.geometry && f.geometry.coordinates; if (!c) continue;
        const ll = L.latLng(c[1], c[0]);
        if (!bounds.contains(ll)) continue; // рисуем только в видимой области
        out.push(f); keep++;
        if (keep > 6000 && stride === 1) break;
      }
      if (out.length) pointsLayer.addData({ type: 'FeatureCollection', features: out });
    }

    // Обновляем подписи/точки (throttle через rAF)
    let raf = 0;
    function scheduleRefresh(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(() => { refreshPoints(); refreshLabels(); }); }
    map.on('zoomend moveend', scheduleRefresh);

    // --- Геолокация (первый фикс — центрирование, далее без автоцентрирования) ---
    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        const ll = [latitude, longitude];
        if (!userMarker) userMarker = L.marker(ll, { title: 'Вы здесь' }).addTo(map); else userMarker.setLatLng(ll);
        if (!accuracyCircle) accuracyCircle = L.circle(ll, { radius: accuracy||0, weight: 1, opacity: 0.5, fillOpacity: 0.06 }).addTo(map);
        else { accuracyCircle.setLatLng(ll); accuracyCircle.setRadius(accuracy||0); }
        if (!didInitialUserCenter) { map.setView(ll, 17, { animate: false }); didInitialUserCenter = true; }
      }, err => { console.warn('Геолокация:', err.message); }, { enableHighAccuracy: true, maximumAge: 15000, timeout: 20000 });
    }

    // --- Загрузка и обработка KML ---
    async function loadKmlFromUrl(url){
      const res=await fetch(url,{cache:'force-cache'});
      const text=await res.text();
      const dom=new DOMParser().parseFromString(text,'text/xml');
      const gj=toGeoJSON.kml(dom);
      if(!gj||!gj.features||!gj.features.length)return;
      const feats=gj.features; featureStore.points=[]; featureStore.shapes=[];
      // разделим по типам
      for(const f of feats){ const t=f.geometry&&f.geometry.type; if(t==='Point') featureStore.points.push(f); else featureStore.shapes.push(f);}    
      // рисуем фигуры сразу
      if(featureStore.shapes.length){ shapesLayer.addData({type:'FeatureCollection',features:featureStore.shapes}); }
      // границы всего KML
      let b=null;
      try{ if(featureStore.shapes.length){ b=L.geoJSON({type:'FeatureCollection',features:featureStore.shapes}).getBounds(); } }catch(_){}
      for(const pf of featureStore.points){ const c=pf.geometry&&pf.geometry.coordinates; if(!c) continue; const ll=L.latLng(c[1],c[0]); if(!b) b=L.latLngBounds(ll,ll); else b.extend(ll); }
      if(b&&b.isValid()) kmlBounds=b;
      scheduleRefresh();
      // если не центрировались на пользователе — показать границы KML
      if(!didInitialUserCenter && kmlBounds && kmlBounds.isValid()) map.fitBounds(kmlBounds,{padding:[24,24]});
    }

    loadKmlFromUrl('/balkhash/kml-line');
  </script>
</body>
</html>
